#!/bin/sh

# Bash has $PROMPT_COMMAND which runs before drawing $PS1
# and trap DEBUG will run just before commands are run
# so we can style everything with those, using PROMPT_COMMAND
# to dynamically set a PS1 string and DEBUG to style output

preexec() {
  # guard against running multiple times for example in a piped chain of
  # commands, or during PROMPT_COMMAND commands which would come after the
  # command is finished, or COMP_LINE commands, otherwise we would stuff
  # these odd control characters into stdin and block pipes and so forth.
  #
  # PROMPT_COMMAND must finish with __preexec_run_once=1 to enable
  if [ 1 -eq ${__preexec_run_once:-0} -a -z "$COMP_LINE" ]
  then
    # run this once before interactive commands are executed
    __preexec_run_once=0
    tput sgr0
  fi
}
# guard against stacking DEBUG handlers
if [ -z "$( trap -p DEBUG 2>/dev/null >/dev/null )" ]
then
  trap 'preexec' DEBUG
fi

#
# PS1 w/blue location line, window-width path, git status, bold command
#

# terminal colors (sgr0 is reset):
# for c in `seq 0 255` sgr0 ; do tput setaf $c ; echo this is a line of color number $c ; done
# variable key, short names because want to scan PS1 on one line
# {w} is "whoami" + "hostname" part
# {p} is path
# {d} is dollar sign
# {Cp} is color for {p}
# {Hw} is highlight for {w}
# {R} is reset

set_PS1() {
  local commandExitCode=$?

  # {Hw} is bold unless {w} matches this string:
  local normal_workstation="david@MacMini-2012:"
  local purple="\[$( tput setaf 54 )\]"
  local   blue="\[$( tput setaf 32 )\]"
  local    red="\[$( tput setaf  9 )\]"

  local R="\[$( tput sgr0 )\]"
  local B="\[$( tput bold )\]"
  local Cp=$purple
  local Cw=$blue
  local Hd=
  local Hw=

  local  w="$( whoami )@$( hostname -s ):"
  local wL="$(( $( tput cols ) - ${#w} ))"  # remaining window width
  local  p="$( pwd_short ${wL} )"

  [ -n "${w/$normal_workstation/}" ] && Hw="$B"
  [ 0 -ne "$commandExitCode" ] && Hd="$red"

  # git status
  local git no_head
  # we want the exit code so cannot use with "local" on same line
  git="$( git_cur_branch 2>/dev/null )"
  no_head=$?
  if [ -n "$git" ]
  then
    local g="$( git rev-parse --git-dir )"
    local v=
    local Hg="$purple"

    # show multi-step or headless state, precendence to bottom of list
    [ 0 -ne $no_head ]           && v="detached head"
    [ -d "$g/rebase-merge" ]     && v="rebase merge"
    [ -d "$g/rebase-apply" ]     && v="rebase apply"
    [ -f "$g/MERGE_HEAD" ]       && v="merge"
    [ -f "$g/CHERRY_PICK_HEAD" ] && v="cherry pick"
    [ -f "$g/REVERT_HEAD" ]      && v="revert"
    [ -f "$g/BISECT_LOG" ]       && v="bisect"

    if [ -n "$v" ]
    then
      Hg="$B$Hg"
    # otherwise show normal commit workflow verb: add,commit,push,pull
    else
      # if git status shows anything with ?? then suggest "add"
      # otherwise suggest "commit" if it prints anything at all
      v=$( git status --porc |
           awk -v FS= '
            $1 == "?" {v="add"}
            {if (!v) v="commit"}
            END {if (v) print v}
           ' )
      if [ -n "$v" ]
      then
        Hg="$red"
      # to here local is unchanged, now look at upstream if any
      # do we have an @{upstream}?
      elif git config --get remote.origin.url >/dev/null 2>/dev/null
      then
        # do we have revisions that we know are not upstream yet?
        if [ 0 -ne "$( git rev-list --right-only --count @{upstream}...HEAD )" ]
        then
          v="push"
        # do we have already fetched revisions that can be pulled, or failing
        # that we ask the remote if it has anything we could pull
        # git_cautious_check_remote caches the answer locally
        elif [ 0 -ne "$( git rev-list --left-only --count @{upstream}...HEAD )" ] ||
             git_cautious_check_remote
        then
          v="pull"
        fi
      fi
    fi

    [ -n "$v" ] && git="$v $git"
    git="$Hg($git)$R"
  fi

  PS1="$R$Hw$Cw$w$R$Cp$p$R\n$git$Hd\$$R $B"
}

PROMPT_COMMAND='set_PS1;update_terminal_cwd;__preexec_run_once=1;'
